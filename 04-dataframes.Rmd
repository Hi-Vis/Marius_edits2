# Dataframes and More

Once you understand the basics of R's data types, some of the more
advanced features of R start to make sense. Below, we'll cover
some of these more advanced features. In particular, we'll discuss
**data frames**, which are used to store and analyse multiple
rows and columns of data bundled together in a table.

## Factors (categorical data)

**Factors** are how R represents categorical data. They
have a fixed number of **levels**, that are set up when you first
create a factor vector:

```{r factor_example}
severity = sample(c("Moderate", "Severe"), 10, replace=TRUE)
# Setting 'levels' also sets the order of the levels
sev_factor = factor(severity, levels = c("Moderate", "Severe"))
sev_factor
```

Factors can only contain data that matches their levels,
and will produce a warning if you try to add something else:

```{r factor_non_level_example}
# Not one of the levels that was set up when the factor was
#   created:
sev_factor[1] = "Mild"
sev_factor
```

## Lists

**Lists** in R can be used to store multiple different types of
data together. Unlike vectors, each element of a list can be a 
different type:

```{r basic_list_example}
list(1, FALSE, "c")
```

One of the most useful features of lists is you can give
each element a name, and then access the data later using
the name. This means you don't have to remember things like
"in these results, the 1st element is the mean and the 2nd is the
variance". To access the named elements of a list, use a dollar sign
`$` or double square brackets `[[]]`:

```{r named_list_example}
results = list(mean = 4.83, variance = 1.09)
results$mean
results[["variance"]]
```

## Dataframes!

The most common format for working with data is in a table, with
data arranged in rows and columns. R's main format for tables
of data is the **dataframe**. In a dataframe:

* Each column is a vector (meaning each column can only contain one
  type of data: numeric, character, factor etc.)[^list-of-vectors]
* Each column has the same length (the number of rows in the dataframe)
* Each column can be assigned a name, so you can access individual
  columns using `df$column_name`
  
[^list-of-vectors]: A dataframe is basically just a list of 
vectors - everything in R is built out of the same basic pieces.
  
Most of the time, you'll read your data from a file (a spreadsheet, an
SPSS file, etc.) and it will be read in as a dataframe. You can also create
dataframes manually:

```{r dataframe_example}
outcomes = data.frame(
    Group = c("Control", "Treatment", "Treatment", "Control"),
    Sex = c("Male", "Female", "Male", "Female"),
    DepressionScore = c(8, 4, 6, 5)
)
outcomes
```

### Accessing parts of dataframes

To access a single column from a dataframe, you can use `$`, which will
return a single vector:

```{r df_single_column}
outcomes$DepressionScore
```

Accessing specific parts of a dataframe, e.g. by filtering out rows based
on a test, is similar to accessing parts of vectors. You use square brackets 
`[]` to index the dataframe, but you can specify both which rows you want
and which columns. The basic syntax is:

```{r, eval=FALSE}
# (don't run: just a general example)
df[rows_to_select, cols_to_select]
```

If you only care about the rows for the current task, you can leave the
other part blank (and likewise for columns):

```{r, eval=FALSE}
# Leave the columns part blank: keep all columns 
df[rows_to_select, ]
# Leave the rows part blank: keep all rows
df[, cols_to_select]
```

There are multiple ways to select the rows, just like with vectors.
You can use a vector of numbers to select by position:

```{r row_num_selection}
# First and third row
outcomes[c(1, 3), ]
```

You can also use a logical index: a vector of `TRUE`/`FALSE` the same length
as the number of rows in the dataframe. Most of the time, you'll create
that logical index by testing one or more columns in the dataframe:

```{r row_logical_selection}
outcomes[outcomes$Group == "Treatment", ]
```

There are also multiple ways to select columns - by position:

```{r col_num_selection}
outcomes[, c(1, 3)]
```

By name:

```{r col_name_selection}
outcomes[, c("Group", "DepressionScore")]
```

Or using a logical vector (this one is a bit less useful, unless the column
names have a specific structure to them). An example using the built-in
`iris` dataset, which contains measurements of different flower species:

```{r col_logical_selection}
# Find all columns that contain "Petal"
head(iris[, stringr::str_detect(colnames(iris), "Petal")])
```

